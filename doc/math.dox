
\fn math_align_poweroftwo
\brief Get smallest greater power-of-two
\details Calculate smallest greater power-of-two. Argument MUST be > 1 or results are undefined
\param x Argument (MUST be >1)
\return Smallest greater power-of-two (or x if it is a power-of-two)

\fn math_is_poweroftwo
\brief Query if power-of-two
\details Query if power-of-two
\param x Argument
\return true if x is a power-of-two, false if not

\fn math_align_up
\brief Get smallest greater multiple
\details Calculate smallest greater multiple of the given base
\param x Argument
\param alignment Alignment
\return Smallest greater multiple of the given alignment

\fn math_smoothstep
\brief Scalar interpolation function
\details Scalar interpolation function with zero first-order derivative at endpoints. smoothstep(t) = 3t^2 - 2t^3
\param t Argument in [0..1]
\return Smoothed value

\fn math_smootherstep
\brief Scalar interpolation function
\details Scalar interpolation function with zero first-order and second-order derivative at endpoints. smoothstep(t) = 6t^5 - 15t^4 + 10t^3
\param t Argument in [0..1]
\return Smoothed value

\fn math_lerp
\brief Linear interpolation function
\details Linear interpolation function
\param t Interpolation factor in [0..1] range
\param x Start value
\param y End value
\return Linear interpolation, x + t * (y-x)

\fn math_unlerp
\brief Inverse linear interpolation function
\details Inverse linear interpolation function
\param v Current value
\param x Start value
\param y End value
\return Linear interpolation factor, t = (v-x) / (y-x)

\fn math_linear_remap
\brief Remap value between intervals
\details Remap a value from source interval to destination interval
\param x Current value
\param xmin Start of source interval
\param xmax End of source interval
\param ymin Start of destination interval
\param ymax End of destination interval
\return Linear remapped value v = ymin + ((x-xmin) / (xmax-xmin)) * (ymax-ymin)

\def math_clamp
\brief Clamp function
\details Clamp value to interval. Note that as a macro it can evaluate arguments multiple times.
\param x Value to clamp
\param minval Start of interval
\param maxval End of interval
\return Value x clamped to [minval,maxval] interval

\fn math_realeq
\brief Compare with tolerance
\details Compare two floats with epsilon tolerance expressed as number of adjacent float values
\param rval First float
\param lval Second float
\param ulps Number of float values in tolerance
\return True if float values are in tolerance range of eachother, false if not

\fn math_realeqns
\brief Compare with tolerance (not sign safe)
\details Compare two floats with epsilon tolerance expressed as number of adjacent float values. This
method (unlike math_realeq) is not sign safe, comparing -x to x for small values of x will yield incorrect results. Most notably will -0 and +0 not be equal.
\param rval First float
\param lval Second float
\param ulps Number of float values in tolerance
\return True if float values are in tolerance range of eachother, false if not

\fn math_realzero
\brief Compare to zero with tolerance
\details Test if float is near zero (within epsilon distance)
\param val Float
\return True if float is within epsilon distance of zero

\fn math_realone
\brief Compare to one with tolerance
\details Test if float is near one (within epsilon distance)
\param val Float
\return True if float is within epsilon distance of one

\fn math_realdec
\brief Decrease floating point value
\details Decrease a floating point value the given number of units
\param val Float
\param units Units
\return Resulting float

\fn math_realinc
\brief Increase floating point value
\details Increase a floating point value the given number of units
\param val Float
\param units Units
\return Resulting float

\fn math_realisnan
\brief Query if value is NaN
\details Query if value is NaN
<pre>+NAN float: 0x7fc00000
-NAN float: 0x7fc00000
+NAN double: 0x7ff8000000000000
-NAN double: 0x7ff8000000000000</pre>
\param val Value
\return true if NaN, false if not

\fn math_realisinf
\brief Query if value is infinite
\details Query if value is infinite
<pre>+INF float: 0x7f800000
-INF float: 0x7f800000
+INF double: 0x7ff0000000000000
-INF double: 0x7ff0000000000000</pre>
\param val Value
\return true if infinite, false if not

\fn math_realisuninitialized
\brief Query if uninitialized
\details Query if value is a compiler specific uninitialized value identifier
\param val Value
\return true if value is an uninitialized value, false if not

\fn math_realisfinite
\brief Query if value is finite
\details Query if value is finite (not NaN, inf or uninitialized)
\param val Value
\return true if finite, false if not

\fn math_realisdenormalized
\brief Query if value is denormalized
\details Query if value is denormalized
\param val Value
\return true if value is denormalized, false if not

\fn math_realundenormalize
\brief Un-denormalize a value
\details Un-denormalize a value
\param val Value
\return 0 if value is denormalized, value if not

\def FOUNDATION_ASSERT_FINITE
\brief Assert that a value is finite
\details Assert that a value is finite
\param value Value

\fn math_inc_wrap_uint8
\brief Increment and wrap
\details Increment and wrap unsigned 8-bit value inside given range
\param val Value to increment
\param min Start of range
\param max End of range
\return Incremented and wrapped value inside range

\fn math_inc_wrap_uint16
\brief Increment and wrap
\details Increment and wrap unsigned 16-bit value inside given range
\param val Value to increment
\param min Start of range
\param max End of range
\return Incremented and wrapped value inside range

\fn math_inc_wrap_uint32
\brief Increment and wrap
\details Increment and wrap unsigned 32-bit value inside given range
\param val Value to increment
\param min Start of range
\param max End of range
\return Incremented and wrapped value inside range

\fn math_inc_wrap_uint64
\brief Increment and wrap
\details Increment and wrap unsigned 64-bit value inside given range
\param val Value to increment
\param min Start of range
\param max End of range
\return Incremented and wrapped value inside range

\fn math_inc_wrap_int8
\brief Increment and wrap
\details Increment and wrap signed 8-bit value inside given range
\param val Value to increment
\param min Start of range
\param max End of range
\return Incremented and wrapped value inside range

\fn math_inc_wrap_int16
\brief Increment and wrap
\details Increment and wrap signed 16-bit value inside given range
\param val Value to increment
\param min Start of range
\param max End of range
\return Incremented and wrapped value inside range

\fn math_inc_wrap_int32
\brief Increment and wrap
\details Increment and wrap signed 32-bit value inside given range
\param val Value to increment
\param min Start of range
\param max End of range
\return Incremented and wrapped value inside range

\fn math_inc_wrap_int64
\brief Increment and wrap
\details Increment and wrap signed 64-bit value inside given range
\param val Value to increment
\param min Start of range
\param max End of range
\return Incremented and wrapped value inside range

\fn math_dec_wrap_uint8
\brief Decrement and wrap
\details Decrement and wrap unsigned 8-bit value inside given range
\param val Value to decrement
\param min Start of range
\param max End of range
\return Decremented and wrapped value inside range

\fn math_dec_wrap_uint16
\brief Decrement and wrap
\details Decrement and wrap unsigned 16-bit value inside given range
\param val Value to decrement
\param min Start of range
\param max End of range
\return Decremented and wrapped value inside range

\fn math_dec_wrap_uint32
\brief Decrement and wrap
\details Decrement and wrap unsigned 32-bit value inside given range
\param val Value to decrement
\param min Start of range
\param max End of range
\return Decremented and wrapped value inside range

\fn math_dec_wrap_uint64
\brief Decrement and wrap
\details Decrement and wrap unsigned 64-bit value inside given range
\param val Value to decrement
\param min Start of range
\param max End of range
\return Decremented and wrapped value inside range

\fn math_dec_wrap_int8
\brief Decrement and wrap
\details Decrement and wrap signed 8-bit value inside given range
\param val Value to decrement
\param min Start of range
\param max End of range
\return Decremented and wrapped value inside range

\fn math_dec_wrap_int16
\brief Decrement and wrap
\details Decrement and wrap signed 16-bit value inside given range
\param val Value to decrement
\param min Start of range
\param max End of range
\return Decremented and wrapped value inside range

\fn math_dec_wrap_int32
\brief Decrement and wrap
\details Decrement and wrap signed 32-bit value inside given range
\param val Value to decrement
\param min Start of range
\param max End of range
\return Decremented and wrapped value inside range

\fn math_dec_wrap_int64
\brief Decrement and wrap
\details Decrement and wrap signed 64-bit value inside given range
\param val Value to decrement
\param min Start of range
\param max End of range
\return Decremented and wrapped value inside range

*/
