
/*!

\struct stream_t
\brief Base stream type
\details Base opaque stream type from which all streams are derived.

\var stream_t::type
\brief Stream type
\details Stream type identifier

\var stream_t::sequential
\brief Sequential flag
\details Flag indicating stream is sequential, meaning it can only read/write sequentially and only seek forward from current position. Generally stream size is unavailable for sequential streams.

\var stream_t::reliable
\brief Reliable flag
\details Flag indicating stream is reliable, meaning data written is guaranteed to be readable.

\var stream_t::inorder
\brief In-order flag
\details Flag indicating stream is in-order, meaning data written is guaranteed to be read in the same order as it was written.

\var stream_t::swap
\brief Byte order swap flag
\details Flag indicating stream is byte order swapped, meaning multi-byte data will be byte order swapped on read/write.

\var stream_t::byteorder
\brief Byte order indicator
\details Stream byte order indicator (0 = little endian, 1 = big endian)

\var stream_t::mode
\brief Stream open mode
\details Stream open mode (see #stream_mode_t)

\var stream_t::path
\brief Stream path
\details Stream path

\var stream_t::vtable
\brief Stream virtual table
\details Stream virtual table with stream type specific implementation function pointers

\struct stream_buffer_t
\brief Memory buffer stream
\details Stream interface for read/write to a memory buffer. This struct is also a stream_t (stream struct type declared at start of struct) and can be used in all functions operating on a stream_t. The memory buffer is allocated separately from the stream buffer.

\var stream_buffer_t::current
\brief Current read/write offset
\details Current read/write offset

\var stream_buffer_t::size
\brief Current size of buffer
\details Current size of buffer (always less or equal than capacity)

\var stream_buffer_t::capacity
\brief Current allocated capacity of buffer
\details Current allocated capacity of buffer

\var stream_buffer_t::buffer
\brief Memory buffer
\details Memory buffer

\var stream_buffer_t::own
\brief Flag indicating ownership of buffer
\details If this flag is set the memory buffer is owned internally by the stream buffer and will be deallocated together with the stream buffer. If not set, the ownership of the memory buffer is handled externally.

\var stream_buffer_t::grow
\brief Flag indicating if memory buffer can grow
\details If this flag is set (and if the memory buffer is owned by the stream buffer), the memory buffer can grow by reallocating memory if write requests increase size beyond the capacity of the memory buffer. If not set, any write requests beyond the capacity will fail.

\struct stream_pipe_t
\brief Pipe stream
\details Stream interface for read/write to a pipe. This struct is also a stream_t (stream struct type declared at start of struct) and can be used in all functions operating on a stream_t.

\var stream_pipe_t::handle_read
\brief Read handle (Windows only)
\details File handle for read end of the pipe.

\var stream_pipe_t::handle_write
\brief Write handle (Windows only)
\details File handle for write end of the pipe.

\var stream_pipe_t::fd_read
\brief Read file descriptor (Posix only)
\details File descriptor for read end of the pipe.

\var stream_pipe_t::fd_write
\brief Write file descriptor (Posix only)
\details File descriptor for write end of the pipe.

\struct stream_ringbuffer_t
\brief Ring buffer stream
\details Stream interface for read/write to a ring buffer. This struct is also a stream_t (stream struct type declared at start of struct) and can be used in all functions operating on a stream_t. Read and write operation can be concurrent (one single thread reading, one single thread writing) as availability of data is flagged with semaphores. Multiple readers and/or writers are not supported. Stream is sequential.

\var stream_ringbuffer_t::signal_read
\brief Read signal
\details Semaphore signalling availability of data for reading

\var stream_ringbuffer_t::signal_write
\brief Write signal
\details Semaphore signalling availability of data for writing

\var stream_ringbuffer_t::pending_read
\brief Number of bytes pending for reading
\details Number of bytes pending for reading

\var stream_ringbuffer_t::pending_write
\brief Number of bytes pending for writing
\details Number of bytes pending for writing

\var stream_ringbuffer_t::total_size
\brief Number of bytes written
\details Number of bytes written (total size of stream)

\struct stream_vtable_t
\brief Stream virtual function table
\details Virtual function table for stream implementations. Each stream type must provide implementation for the basic stream operations in this struct or set the entry to null to indicate that the functionality is not supported by the stream type.

\var stream_vtable_t::read
\brief Read function
\details Function to read data from stream.

\var stream_vtable_t::write
\brief Write function
\details Function to write data to stream.

\var stream_vtable_t::eos
\brief Query if end of stream
\details Function to query if current position is at end of stream.

\var stream_vtable_t::flush
\brief Flush data
\details Function to flush any pending data to stream.

\var stream_vtable_t::truncate
\brief Truncate to current position
\details Function to truncate stream to current position.

\var stream_vtable_t::size
\brief Query size
\details Function to query size of stream

\var stream_vtable_t::seek
\brief Seek function
\details Function to seek in stream.

\var stream_vtable_t::tell
\brief Query current position
\details Function to query the current position in the stream.

\var stream_vtable_t::lastmod
\brief Query last modification timestamp
\details Function to query the last modification timestamp of the stream.

\var stream_vtable_t::md5
\brief Query hash
\details Function to query the MD5 of the stream content

\var stream_vtable_t::buffer_read
\brief Buffer data
\details Function to buffer any incoming data for the stream.

\var stream_vtable_t::available_read
\brief Query available data
\details Function to query the amount of data that can be read without blocking.

\var stream_vtable_t::finalize
\brief Finalization function
\details Function to finalize the stream, free memory and release any resources associated with the stream.

\var stream_vtable_t::clone
\brief Clone function
\details Function to clone the stream.

\typedef mutex_t
\brief Mutex
\details Mutex for thread synchronization

\struct process_t
\brief Process
\details Opaque struct holding state for a process

\var process_t::wd
\brief Working directory
\details Working directory

\var process_t::path
\brief Executable path
\details Executable path

\var process_t::args
\brief Argument array
\details Array of argument strings

\var process_t::flags
\brief Flags
\details Flags, see #process_flag_t

\var process_t::code
\brief Exit code
\details Exit code for the process

\var process_t::pipeout
\brief Pipe for stdout
\details Pipe stream for stdout

\var process_t::pipein
\brief Pipe for stdin
\details Pipe stream for stdin

\var process_t::verb
\brief Shell verb
\details Windows only, shell verb used when launching process with ShellExecute

\var process_t::hp
\brief Process handle
\details Windows only, process handle

\var process_t::ht
\brief Thread handle
\details Windows only, thread handle

\var process_t::pid
\brief Process identifier
\details Posix only, process identifier

\var process_t::kq
\brief Process kqueue
\details MaxOS X only, kqueue for watching for process termination when launching process with LSOpenApplication

\struct event_block_t
\brief Event block
\details Event block holding a number of events for processing. Block can be maximum BUILD_SIZE_EVENT_BLOCK_LIMIT bytes in size

\var event_block_t::used
\brief Number of events pending
\details Number of events pending

\var event_block_t::capacity
\brief Capacity of event store buffer
\details Capacity of event store buffer

\var event_block_t::stream
\brief Event stream
\details Event stream owning this event block

\var event_block_t::events
\brief Event buffer
\details Memory buffer holding event data

\struct event_stream_t
\brief Event stream
\details Event stream from a single module. Event streams produce event blocks for processing

\var event_stream_t::write
\brief Write block index
\details Write block index

\var event_stream_t::read
\brief Read block index
\details Read block index

\var event_stream_t::block
\brief Event blocks
\details Event blocks, double buffered for concurrent read/write access

\struct ringbuffer_t
\brief Ringbuffer
\details Ring buffer, a shared memory area wrapped to a circular buffer with one read and one get pointer.

\var ringbuffer_t::total_read
\brief Total bytes read
\details Total number of bytes read from ring buffer

\var ringbuffer_t::total_write
\brief Total bytes written
\details Total number of bytes written to ring buffer

\var ringbuffer_t::offset_read
\brief Read offset
\details Current read offset

\var ringbuffer_t::offset_write
\brief Write offset
\details Current write offset

\var ringbuffer_t::buffer_size
\brief Size of buffer
\details Size of buffer in bytes

\var ringbuffer_t::buffer
\brief Buffer
\details Memory buffer

\struct blowfish_t
\brief Blowfish state
\details State for a blowfish encryption block

\var blowfish_t::parray
\brief Blowfish P-array
\details Blowfish P-array

\var blowfish_t::sboxes
\brief Blowfish S-boxes
\details Blowfish S-boxes

\struct radixsort_t
\brief Radix sorter
\details State for a radix sorter for a defined data type.

\var radixsort_t::type
\brief Data type
\details Data type being sorted

\var radixsort_t::size
\brief Maximum number of elements
\details Maximum number of elements that can be sorted

\var radixsort_t::lastused
\brief Number of elements in last sort
\details Number of elements in last call to #radixsort

\var radixsort_t::indices
\brief Index buffers
\details Index buffers holding sorted result

\var radixsort_t::histogram
\brief Histogram buffer
\details Buffer for histogram data

\var radixsort_t::offset
\brief Offset table
\details Offset table

\struct hashmap_t
\brief Hash map
\details Hash map container, mapping hash values to data pointers

\var hashmap_t::num_buckets
\brief Number of buckets
\details Number of buckets in the hash map.

\var hashmap_t::num_nodes
\brief Number of nodes
\details Total number of nodes in the hash map across all buckets.

\var hashmap_t::bucket
\brief Bucket array
\details Bucket array, represented as an array of hashmap_node_t arrays, which will be dynamically allocated
and reallocated to the required sizes.

\struct hashmap_node_t
\brief Hash map node
\details Single node in a hash map, mapping a single key to a single data value (pointer).

\var hashmap_node_t::key
\brief Hash map node key
\details Key for the hash map node.

\var hashmap_node_t::value
\brief Hash map node value
\details Value for the hash map node.

\struct hashtable32_entry_t
\brief Node in 32-bit hash table
\details Node in 32-bit hash table holding key and value for a single node.

\var hashtable32_entry_t::key
\brief Hash key
\details Hash key for node in hash table.

\var hashtable32_entry_t::value
\brief Value
\details Value for the corresponding hash key. If the value is zero the node is considered unused.

\struct hashtable64_entry_t
\brief Node in 64-bit hash table
\details Node in 64-bit hash table holding key and value for a single node.

\var hashtable64_entry_t::key
\brief Hash key
\details Hash key for node in hash table.

\var hashtable64_entry_t::value
\brief Value
\details Value for the corresponding hash key. If the value is zero the node is considered unused.

\struct hashtable32_t
\brief Hash table (32 bit data)
\details Hash table, a lock free mapping of hash values to 32 bit integer data.

\var hashtable32_t::capacity
\brief Capacity of table
\details Number of nodes in the table, i.e maximum number of key-value pairs that can be stored.

\var hashtable32_t::entries
\brief Table storage
\details Hash table storage as array of nodes where each node is a key-value pair.

\struct hashtable64_t
\brief Hash table (64 bit data)
\details Opaque struct holding state for a hash table, a lock free mapping of hash values to 64 bit integer data.

\var hashtable64_t::capacity
\brief Capacity of table
\details Number of nodes in the table, i.e maximum number of key-value pairs that can be stored.

\var hashtable64_t::entries
\brief Table storage
\details Hash table storage as array of nodes where each node is a key-value pair.

\struct regex_t
\brief Compiled regular expression
\details Opaque struct holding state for a compiled regular expression

\var regex_t::num_captures
\brief Number of captures
\details Counter during regex matching keeping number of currently captured substrings

\var regex_t::code_length
\brief Length of compiled code
\details Length of the compiled code array

\var regex_t::code_allocated
\brief Capacity of code array
\details Capacity of the code array (number of bytes)

\var regex_t::code
\brief Compiled code
\details Compiled regex code


\struct memory_tracker_t
\brief Memory tracking system declaration
\details Memory tracking system declarations with function pointers for all memory tracking entry points

\var memory_tracker_t::track
\brief Track a memory allocation
\details Track a memory allocation

\var memory_tracker_t::untrack
\brief Untrack a memory allocation
\details Untrack a memory allocation

\var memory_tracker_t::initialize
\brief Initialize memory tracker
\details Initialize memory tracker

\var memory_tracker_t::shutdown
\brief Shutdown memory tracker
\details Shutdown memory tracker

\union version_t
\brief Version identifier
\details Version identifier expressed as an 128-bit integer with major, minor, revision, build and control version number components

\var version_t::version
\brief Compound version
\details Compound version identifier

\var version_t::sub
\brief Version numbers
\details Version numbers separated into sections, "major.minor.revision-revision (control)"

\var version_t::sub.major
\brief Major version
\details Major version

\var version_t::sub.minor
\brief Minor version
\details Minor version

\var version_t::sub.revision
\brief Revision number
\details Revision number

\var version_t::sub.build
\brief Build number
\details Build number

\var version_t::sub.revision
\brief Source control version/revision/identifier
\details Source control version/revision/identifier

\var float32_cast_t::ival
\brief Integer interpretation
\details Integer interpretation of 32-bit floating point value

\var float32_cast_t::fval
\brief Float interpretation
\details Float interpretation of 32-bit floating point value

\var float64_cast_t::ival
\brief Integer interpretation
\details Integer interpretation of 64-bit floating point value

\var float64_cast_t::fval
\brief Float interpretation
\details Float interpretation of 64-bit floating point value

\var real_cast_t::ival
\brief Integer interpretation
\details Integer interpretation of real floating point value

\var real_cast_t::rval
\brief Float interpretation
\details Float interpretation of real floating point value

\struct application_t
\brief Application declaration
\details Application declaration

\var application_t::name
\brief Long name
\details Long descriptive name

\var application_t::short_name
\brief Short name
\details Short name, should only contain [a-z][A-Z][-_.]

\var application_t::config_dir
\brief Config directory
\details Config directory name

\var application_t::version
\brief Version
\details Version declaration

\var application_t::dump_callback
\brief Crash callback
\details Crash dump callback function

\var application_t::flags
\brief Application flags
\details Application flags (see application_flag_t)

\var application_t::instance
\brief Instance UUID
\details Instance UUID, generated by the foundation library on foundation initialization

\struct error_frame_t
\brief Data for a frame in the error context stack
\details Data for a frame in the error context stack

\var error_frame_t::name
\brief Error description
\details Error description

\var error_frame_t::data
\brief Data associated with error
\details Data associated with error

\struct error_context_t
\brief Error context stack
\details Error context stack

\var error_context_t::frame
\brief Error context stack
\details Error context stack

\var error_context_t::depth
\details Current depth
\details Current depth of error context stack

\struct memory_context_t
\brief Memory context stack
\details Memory context stack

\var memory_context_t::context
\brief Memory context stack
\details Memory context stack

\var memory_context_t::depth
\details Current depth
\details Current depth of memory context stack


\def FOUNDATION_DECLARE_OBJECT
\brief Object base structure declaration
\details Declares the base object data layout. Object structures should be 8-byte align for platform compatibility.
Use the macro as first declaration in an object struct:
<pre>typedef struct ALIGN(8)
{
  FOUNDATION_DECLARE_OBJECT;
  int       some_other_data;
  //[...]
} my_object_t;</pre>
\internal If changing base object layout, change objectmap_lookup and objectmap_lookup_ref \endinternal

\struct object_base_t
\brief Object base structure
\details Object base structure. All object-based designs must have this layout at the start of the structure.
See #FOUNDATION_DECLARE_OBJECT for a macro to declare the base layout in a structure.

\var object_base_t::ref
\brief Object reference count
\details Object reference count

\var object_base_t::flags
\brief Object flags
\details Object flags

\var object_base_t::id
\brief Object ID and handle (self)
\details Object ID and handle (self)

\struct objectmap_t
\brief Object map
\details Object map which maps object handles to object pointers. As object lifetime is managed by
reference counting, objects that are deallocated will invalidate the handle in the corresponding
object map.

\var objectmap_t::free
\brief Current first free slot
\details Current first free slot

\var objectmap_t::size
\brief Number of slots in map
\details Number of slots in map

\var objectmap_t::id
\brief Counter for next available ID
\details Counter for next available ID

\var objectmap_t::size_bits
\brief Number of bits needed for slot index
\details Number of bits needed for slot index

\var objectmap_t::id_max
\brief Maximum ID
\details Maximum ID depending on how many bits are used by size

\var objectmap_t::mask_index
\brief Bitmask for slot index
\details Bitmask for slot index

\var objectmap_t::mask_id
\brief Bitmask for ID
\details Bitmask for ID

\var objectmap_t::map
\brief Slot array
\details Slot array

\def FOUNDATION_DECLARE_EVENT
\brief Event base structure declaration
\details Declares the base event data layout. Event structures should use the macro as first
declaration in an event struct:
<pre>typedef struct
{
  FOUNDATION_DECLARE_EVENT;
  int some_other_data;
  //[...]
} my_event_t;</pre>

\struct event_t
\brief Event base structure
\details Event base structure. All event structures must have this layout at the start of the structure.
See #FOUNDATION_DECLARE_EVENT for a macro to declare the base layout in a structure.

\var event_t::id
\brief Event ID
\details Event ID

\var event_t::flags
\brief Event flags
\details Event flags

\var event_t::serial
\brief Event serial number
\details Event serial number

\var event_t::size
\brief Size of event data payload
\details Size of event data payload

\var event_t::object
\brief Object associated with event
\details Object associated with event

\var event_t::payload
\brief Event data payload
\details Event data payload

\struct semaphore_t
\brief Semaphore
\details Semaphore for thread synchronization and communication. Actual type specifics depend
on platform, the semaphore_t type should be treated as an opaque data struct.

\struct bitbuffer_t
\brief Bit buffer
\details Bit buffer for bit based I/O to a memory buffer or stream

\var bitbuffer_t::buffer
\brief Memory buffer
\details Memory buffer for buffer based I/O

\var bitbuffer_t::end
\brief End of buffer indicator
\details End of buffer indicator

\var bitbuffer_t::stream
\brief Stream
\details Stream for stream based I/O

\var bitbuffer_t::swap
\brief Swap flag
\details Swap flag for compatibility between machines with different endian architectures

\var bitbuffer_t::pending_read
\brief Pending data to be read
\details Pending data to be read

\var bitbuffer_t::pending_write
\brief Pending data to be written
\details Pending data to be written

\var bitbuffer_t::offset_read
\brief Current read offset
\details Current read offset in bits into pending data

\var bitbuffer_t::offset_write
\brief Current write offset
\details Current write offset in bits into pending data

\var bitbuffer_t::count_read
\brief Number of read bits
\details Total number of read bits

\var bitbuffer_t::count_write
\brief Number of written bits
\details Total number of written bits


\struct regex_capture_t
\brief Regex capture
\details Regex capture. Used to capture matching in a regex search. See regex_match in regex.h

\var regex_capture_t::substring
\brief Captured substring (NOT null terminated)
\details Captured substring (NOT null terminated)

\var regex_capture_t::length
\brief Length of captured substring
\details Length of captured substring


\fn version_t version_make( unsigned int major, unsigned int minor, unsigned int revision, unsigned int build, unsigned int control )
\brief Pack version definition into a 128-bit integer
\details Pack version definition into a 128-bit integer
\param major          Major version
\param minor          Minor version
\param revision       Revision number
\param build          Build number
\param control        Source control version/revision/identifier
\return               Packed version data


*/
